
工厂模式
  1.简单工厂模式（Simple Factory）
  有客户端通过参数选择要什么产品，通过工厂获得该产品的实例
  2.工厂方法模式（Factory Method）
  定义工厂接口，子类实现接口，由子类选择决定创建那个具体的产品，客户选择相应的子类的即可选择想要的产品
  3.抽象工厂模式
  客户端通过抽象工厂获取已有的产品实例，每个抽象方法对应一个实例
单例模式
    1.饿汉式
    未使用前就已经初始化。
    决定线程安全、执行效率高,但是未使用时，会占用内存
    2.懒汉式
    第一次使用时，才进行初始化。
    需考虑线程安全（synchronized:效率低下、内部类：兼顾线程安全和效率）
    问题：
    1.内部类方式的单例：如何保证initial变量暴力修改，导致出现多个实例
    2.注册方式的单例：如何保证线程安全，从而不出现多个实例
    
原型模式
    对象的深度克隆，产生一个新的对象
    实现方式：序列化，反射
    问题：反射实现深度克隆
代理模式
    代理类持有被代理类的引用，调用被代理类的行为，并添加自己的逻辑
    
策略模式
    根据客户端的参数，选择某种方案。方案接受的参数以及结果一样，只是行为不一样。
模板模式    
    流程大部分工序是固定的，只有少部分工序是可变的

委派模式
    主类接受任务，并分发给相应的类处理任务，不参与具体任务
适配器模式
    在不改变被适配的类（可以是接口）的逻辑基础，重新创建一个适配器类（可以是接口），适应新的业务逻辑

装饰器模式
    是一种特殊的适配器模式，与适配器比较
    -------------------------------|---------------------------------
    装饰器模式                     |适配器模式
    -------------------------------|---------------------------------
    is-a关系                       |has-a关系
    -------------------------------|---------------------------------
    注重覆盖和扩展                 |注重兼容和转换
    -------------------------------|---------------------------------
    装饰者和被装饰者实现同一接口   |通常是使用代理或者继承形式包装
    主要是为了扩展，依旧保留OOP关系|但是没有必然的层级关系系
    -------------------------------|---------------------------------